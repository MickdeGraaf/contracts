digraph "" {
ElasticDAO -> ReentryProtection;
ElasticDAO[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ElasticDAO</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    exit(uint256)</TD></TR><TR><TD align="left">    initializeToken(string,string,uint256,uint256,uint256,uint256)</TD></TR><TR><TD align="left">    join(uint256)</TD></TR><TR><TD align="left">    setController(address)</TD></TR><TR><TD align="left">    setMaxVotingLambda(uint256)</TD></TR><TR><TD align="left">    seedSummoning()</TD></TR><TR><TD align="left">    summon(uint256)</TD></TR><TR><TD align="left">    getDAO()</TD></TR><TR><TD align="left">    getEcosystem()</TD></TR><TR><TD align="left">    receive()</TD></TR><TR><TD align="left">    fallback()</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _getDAO()</TD></TR><TR><TD align="left">    _getEcosystem()</TD></TR><TR><TD align="left">    _getToken()</TD></TR><TR><TD align="left"><I>Modifiers:</I></TD></TR><TR><TD align="left">    onlyAfterSummoning()</TD></TR><TR><TD align="left">    onlyAfterTokenInitialized()</TD></TR><TR><TD align="left">    onlyBeforeSummoning()</TD></TR><TR><TD align="left">    onlyController()</TD></TR><TR><TD align="left">    onlyDeployer()</TD></TR><TR><TD align="left">    onlySummoners()</TD></TR><TR><TD align="left">    onlyWhenOpen()</TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    deployer</TD></TR><TR><TD align="left">    ecosystemModelAddress</TD></TR><TR><TD align="left">    controller</TD></TR><TR><TD align="left">    summoners</TD></TR><TR><TD align="left">    maxVotingLambda</TD></TR></TABLE> >];

ElasticDAOFactory -> ReentryProtection;
ElasticDAOFactory[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ElasticDAOFactory</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    deployDAOAndToken(address[],string,uint256,string,string,uint256,uint256,uint256,uint256)</TD></TR><TR><TD align="left">    updateFeeAddress(address)</TD></TR><TR><TD align="left">    collectFees()</TD></TR><TR><TD align="left">    receive()</TD></TR><TR><TD align="left">    fallback()</TD></TR><TR><TD align="left"><I>Modifiers:</I></TD></TR><TR><TD align="left">    onlyDeployer()</TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    deployer</TD></TR><TR><TD align="left">    ecosystemModelAddress</TD></TR><TR><TD align="left">    deployedDAOAddresses</TD></TR><TR><TD align="left">    deployedDAOCount</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    feeAddress</TD></TR></TABLE> >];

IERC20[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IERC20</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    allowance(address,address)</TD></TR><TR><TD align="left">    approve(address,uint256)</TD></TR><TR><TD align="left">    balanceOf(address)</TD></TR><TR><TD align="left">    totalSupply()</TD></TR><TR><TD align="left">    transfer(address,uint256)</TD></TR><TR><TD align="left">    transferFrom(address,address,uint256)</TD></TR></TABLE> >];

IElasticToken -> IERC20;
IElasticToken[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IElasticToken</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    balanceOfInShares(address)</TD></TR><TR><TD align="left">    burn(address,uint256)</TD></TR><TR><TD align="left">    burnShares(address,uint256)</TD></TR><TR><TD align="left">    mintShares(address,uint256)</TD></TR><TR><TD align="left">    numberOfTokenHolders()</TD></TR><TR><TD align="left">    totalSupplyInShares()</TD></TR></TABLE> >];

ElasticMath[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ElasticMath</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    capitalDelta(uint256,uint256)</TD></TR><TR><TD align="left">    deltaE(uint256,uint256,uint256,uint256,uint256,uint256)</TD></TR><TR><TD align="left">    lambdaFromT(uint256,uint256,uint256)</TD></TR><TR><TD align="left">    mDash(uint256,uint256,uint256)</TD></TR><TR><TD align="left">    revamp(uint256)</TD></TR><TR><TD align="left">    t(uint256,uint256,uint256)</TD></TR><TR><TD align="left">    wmul(uint256,uint256)</TD></TR><TR><TD align="left">    wdiv(uint256,uint256)</TD></TR></TABLE> >];

SafeMath[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>SafeMath</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    add(uint256,uint256)</TD></TR><TR><TD align="left">    sub(uint256,uint256)</TD></TR><TR><TD align="left">    sub(uint256,uint256,string)</TD></TR><TR><TD align="left">    mul(uint256,uint256)</TD></TR><TR><TD align="left">    pow(uint256,uint256)</TD></TR></TABLE> >];

DAO -> EternalModel [ label="1" ];
DAO -> ReentryProtection [ label="2" ];
DAO[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>DAO</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    deserialize(address,Ecosystem.Instance)</TD></TR><TR><TD align="left">    exists(address,Ecosystem.Instance)</TD></TR><TR><TD align="left">    getSummoner(DAO.Instance,uint256)</TD></TR><TR><TD align="left">    isSummoner(DAO.Instance,address)</TD></TR><TR><TD align="left">    serialize(DAO.Instance)</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _exists(address)</TD></TR></TABLE> >];

Ecosystem -> EternalModel [ label="1" ];
Ecosystem -> ReentryProtection [ label="2" ];
Ecosystem[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>Ecosystem</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    deserialize(address)</TD></TR><TR><TD align="left">    exists(address)</TD></TR><TR><TD align="left">    serialize(Ecosystem.Instance)</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _exists(address)</TD></TR></TABLE> >];

EternalModel[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>EternalModel</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    getUint(bytes32)</TD></TR><TR><TD align="left">    getString(bytes32)</TD></TR><TR><TD align="left">    getAddress(bytes32)</TD></TR><TR><TD align="left">    getBool(bytes32)</TD></TR><TR><TD align="left">    setUint(bytes32,uint256)</TD></TR><TR><TD align="left">    setString(bytes32,string)</TD></TR><TR><TD align="left">    setAddress(bytes32,address)</TD></TR><TR><TD align="left">    setBool(bytes32,bool)</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    s</TD></TR></TABLE> >];

Token -> EternalModel [ label="1" ];
Token -> ReentryProtection [ label="2" ];
Token[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>Token</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    deserialize(address,Ecosystem.Instance)</TD></TR><TR><TD align="left">    exists(address,Ecosystem.Instance)</TD></TR><TR><TD align="left">    incrementCounter(Token.Instance)</TD></TR><TR><TD align="left">    serialize(Token.Instance)</TD></TR><TR><TD align="left">    updateNumberOfTokenHolders(Token.Instance,uint256)</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _exists(address)</TD></TR></TABLE> >];

TokenHolder -> EternalModel [ label="1" ];
TokenHolder -> ReentryProtection [ label="2" ];
TokenHolder[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>TokenHolder</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    deserialize(address,Ecosystem.Instance,Token.Instance)</TD></TR><TR><TD align="left">    exists(address,Token.Instance)</TD></TR><TR><TD align="left">    serialize(TokenHolder.Instance)</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _exists(address,Token.Instance)</TD></TR></TABLE> >];

Configurator[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>Configurator</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    buildDAO(address[],string,uint256,Ecosystem.Instance)</TD></TR><TR><TD align="left">    buildEcosystem(Ecosystem.Instance)</TD></TR><TR><TD align="left">    buildToken(string,string,uint256,uint256,uint256,uint256,Ecosystem.Instance)</TD></TR></TABLE> >];

ReentryProtection[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ReentryProtection</B></TD></TR><TR><TD align="left"><I>Modifiers:</I></TD></TR><TR><TD align="left">    preventReentry()</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    mutex</TD></TR></TABLE> >];

ElasticGovernanceToken -> IElasticToken [ label="1" ];
ElasticGovernanceToken -> ReentryProtection [ label="2" ];
ElasticGovernanceToken[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ElasticGovernanceToken</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    allowance(address,address)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    approve(address,uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    balanceOf(address)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    balanceOfInShares(address)</font></TD></TR><TR><TD align="left">    balanceOfVoting(address)</TD></TR><TR><TD align="left"><font color="#FFA500">    burn(address,uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    burnShares(address,uint256)</font></TD></TR><TR><TD align="left">    decimals()</TD></TR><TR><TD align="left">    decreaseAllowance(address,uint256)</TD></TR><TR><TD align="left">    increaseAllowance(address,uint256)</TD></TR><TR><TD align="left">    mint(address,uint256)</TD></TR><TR><TD align="left"><font color="#FFA500">    mintShares(address,uint256)</font></TD></TR><TR><TD align="left">    name()</TD></TR><TR><TD align="left"><font color="#FFA500">    numberOfTokenHolders()</font></TD></TR><TR><TD align="left">    setBurner(address)</TD></TR><TR><TD align="left">    setMinter(address)</TD></TR><TR><TD align="left">    symbol()</TD></TR><TR><TD align="left"><font color="#FFA500">    totalSupply()</font></TD></TR><TR><TD align="left"><font color="#FFA500">    totalSupplyInShares()</font></TD></TR><TR><TD align="left"><font color="#FFA500">    transfer(address,uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    transferFrom(address,address,uint256)</font></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _approve(address,address,uint256)</TD></TR><TR><TD align="left">    _burn(address,uint256)</TD></TR><TR><TD align="left">    _burnShares(address,uint256)</TD></TR><TR><TD align="left">    _mint(address,uint256)</TD></TR><TR><TD align="left">    _mintShares(address,uint256)</TD></TR><TR><TD align="left">    _transfer(address,address,uint256)</TD></TR><TR><TD align="left">    _updateBalance(Token.Instance,TokenHolder.Instance,bool,uint256)</TD></TR><TR><TD align="left">    _updateNumberOfTokenHolders(bool,Token.Instance,TokenHolder.Instance,Token)</TD></TR><TR><TD align="left">    _getEcosystem()</TD></TR><TR><TD align="left">    _getTokenHolder(address)</TD></TR><TR><TD align="left">    _getToken()</TD></TR><TR><TD align="left"><I>Modifiers:</I></TD></TR><TR><TD align="left">    onlyDAO()</TD></TR><TR><TD align="left">    onlyDAOorBurner()</TD></TR><TR><TD align="left">    onlyDAOorMinter()</TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    burner</TD></TR><TR><TD align="left">    daoAddress</TD></TR><TR><TD align="left">    ecosystemModelAddress</TD></TR><TR><TD align="left">    minter</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    _allowances</TD></TR></TABLE> >];

}